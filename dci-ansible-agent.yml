---
# Initial Step:
#
# Schedule a new job giving a specific topic and specifying the remote CI.
# The return of this action contains all the data associated with the job,
# we hence register those data for later consumptions
#
- hosts: localhost
  tasks:
    - name: Schedule a new job
      dci_job:
        components: '{{ dci_components|default([]) }}'
        topic: '{{ dci_topic }}'
      register: new_job_informations

    - set_fact:
        job_id: '{{ hostvars.localhost.job_informations.job.id }}'
        components: '{{ hostvars.localhost.job_informations.job.components }}'
    - name: Set the metadata
      dci_job:
        id: "{{ job_informations.job.id }}"
        metadata: '{{ dci_metadata }}'
      when: dci_metadata is defined and dci_metadata

- name: 'Sanity check'
  hosts: localhost
  vars:
    dci_status: 'new'
  tasks:
    - block:
      - name: Check the jumpbox sanity
        include: plays/sanity_check.yml

      - include: plays/purge_cache.yml

      - include: plays/prepare_local_mirror.yml

      - include: plays/fetch_bits.yml

      - set_fact:
          dci_status: 'pre-run'

      - include: '{{ dci_config_dir }}/hooks/pre-run.yml'

      rescue:
      - include: "{{ dci_config_dir }}/hooks/teardown.yml"
        when: dci_teardown_on_failure is defined and dci_teardown_on_failure

      - include: plays/failure.yml


# Run state
#
# User is free to do whaterver she needs before entering running state.
# Usually this is used to provision both undercloud and the overcloud.
#
- name: 'Provision the undercloud and the overcloud'
  hosts: localhost
  vars:
    dci_status: 'running'
    next_topic:
      OSP9: 'OSP10'
      OSP10: 'OSP11'
      OSP11: 'OSP12'
  tasks:
    - block:
      - set_fact:
          # job_informations may be redefined below. We need a set_fact here to
          # store a static result.
          update_playbook: '{{ dci_config_dir }}/hooks/update_{{ job_informations.job.topic.name }}.yml'
          upgrade_playbook: '{{ dci_config_dir }}/hooks/upgrade_from_{{ job_informations.job.topic.name }}_to_{{ next_topic[job_informations.job.topic.name] }}.yml'
      - stat:
          path: '{{ update_playbook }}'
        register: update_playbook_stat
      - stat:
          path: '{{ upgrade_playbook }}'
        register: upgrade_playbook_stat

      - include: '{{ dci_config_dir }}/hooks/running.yml'

      - include: plays/register_undercloud_host.yml

      # RUN TESTS

      - include: '{{ update_playbook }}'
        when: job_informations.job.rconfiguration.data.is_frozen is defined

      # RUN TESTS

      - dci_job:
          id: '{{ job_informations.job.id }}'
          upgrade: True
        register: new_job_informations
        when: update_playbook_stat.stat.exists

      - debug:
          var: new_job_informations

      - set_fact:
          job_id: '{{ hostvars.localhost.job_informations.job.id }}'
          job_informations: '{{ new_job_informations.changed|ternary(new_job_informations, job_informations)}}'

      - set_fact:
          dci_status: 'pre-run'

      - include: plays/fetch_bits.yml
        when: update_playbook_stat.stat.exists

      - set_fact:
          dci_status: 'running'

      - include: '{{ upgrade_playbook }}'
        when: update_playbook_stat.stat.exists


      # RUN TESTS

      rescue:
      # Included a second time in case of failure in hooks/running.yml,
      # this is required for collect-logs to work
      - include: plays/register_undercloud_host.yml

      - include_role:
          name: "{{ dci_topic }}/collect-logs"
        delegate_to: undercloud
        ignore_errors: True

      - include: "{{ dci_config_dir }}/hooks/teardown.yml"
        when: dci_teardown_on_failure is defined and dci_teardown_on_failure

      - include: plays/failure.yml


# Post-run state
#
# User is free to do whaterver she needs before entering post-run state.
# Usually this is used to run tests, certifications, etc...
#
- name: 'Running tests'
  hosts: 'undercloud'
  tasks:
    - block:
      - include: play/run_tests.yml

      rescue:
      - include: "{{ dci_config_dir }}/hooks/teardown.yml"
        when: dci_teardown_on_failure is defined and dci_teardown_on_failure
        delegate_to: localhost

      - include: plays/failure.yml
        delegate_to: localhost


- name: Collect logs
  hosts: 'undercloud'
  vars:
    dci_status: 'post-run'
    artcl_tar_gz: true
    artcl_gzip_only: false
  tasks:
    - block:
      - include_role:
          name: "{{ dci_topic }}/collect-logs"

      rescue:
      - include: "{{ dci_config_dir }}/hooks/teardown.yml"
        when: dci_teardown_on_failure is defined and dci_teardown_on_failure
        delegate_to: localhost

      - include: plays/failure.yml
        delegate_to: localhost


- name: 'Upload files'
  hosts: localhost
  vars:
    dci_status: 'post-run'
  tasks:
    - block:
      - include: plays/upload_logs.yml

      rescue:
      - include: "{{ dci_config_dir }}/hooks/teardown.yml"
        when: dci_teardown_on_failure is defined and dci_teardown_on_failure

      - include: plays/failure.yml


# Success state
#
# User is free to do whaterver she needs before entering pre-run state.
# Usually this is used to teardown the plateform
#
- name: 'Successful installation'
  hosts: localhost
  vars:
    dci_status: 'success'
  tasks:
    - include: "{{ dci_config_dir }}/hooks/success.yml"

    - include: "{{ dci_config_dir }}/hooks/teardown.yml"
